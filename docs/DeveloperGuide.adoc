= The Myth's Book - Developer Guide
:toc:
:toc-title:
:toc-placement: preamble
:sectnums:
:imagesDir: images
:stylesDir: stylesheets
ifdef::env-github[]
:tip-caption: :bulb:
:note-caption: :information_source:
endif::[]
ifdef::env-github,env-browser[:outfilesuffix: .adoc]
:repoURL: https://github.com/CS2103AUG2017-T15-B3/main

By: `The Myth`      Since: `Jun 2016`      Licence: `MIT`

== Introduction

The Myth's Book is an address book dedicated for university students to store useful information such
as websites, phone numbers and emails of the people around them for personal usage. The application helps students
to keep track of birthday dates and upcoming events through a calendar and facilitate convenient access to their friend's website
and even Google Maps location through the in-built browser panel in the application. Furthermore, there are many
useful tools such as finding group tags (e.g. friends, neighbours) and switching themes for better user preference and usability.

The Myth's Book is a `Command Line Input` based software which helps caters to students who are efficient and comfortable
in typing out command line inputs to manipulate with information of their contacts in the address book.
The Myth's Book is a software application that is coded in `Java` programming language.

== About

This developer guide will teach you how to set up the application software on IntelliJ IDEA and
allow you to understand the process, features and structure of the application software to help
you become a more knowledgeable contributor towards debugging, updating and improving The Myth's Book.

== Setting up

=== Prerequisites

. *JDK `1.8.0_60`* or later
+
[NOTE]
Having any Java 8 version is not enough. +
This app will not work with earlier versions of Java 8.
+

. *IntelliJ* IDE
+
[NOTE]
IntelliJ by default has Gradle and JavaFx plugins installed. +
Do not disable them. If you have disabled them, go to `File` > `Settings` > `Plugins` to re-enable them.


=== Setting up the project in your computer

. Fork this repo, and clone the fork to your computer
. Open IntelliJ (if you are not in the welcome screen, click `File` > `Close Project` to close the existing project dialog first)
. Set up the correct JDK version for Gradle
.. Click `Configure` > `Project Defaults` > `Project Structure`
.. Click `New...` and find the directory of the JDK
. Click `Import Project`
. Locate the `build.gradle` file and select it. Click `OK`
. Click `Open as Project`
. Click `OK` to accept the default settings
. Open a console and run the command `gradlew processResources` (Mac/Linux: `./gradlew processResources`). It should finish with the `BUILD SUCCESSFUL` message. +
This will generate all resources required by the application and tests.

=== Verifying the setup

. Run the `seedu.address.MainApp` and try a few commands
. link:#testing[Run the tests] to ensure they all pass.

=== Configurations to do before writing code

==== Configuring the coding style

This project follows https://github.com/oss-generic/process/blob/master/docs/CodingStandards.md[oss-generic coding standards]. IntelliJ's default style is mostly compliant with ours but it uses a different import order from ours. To rectify,

. Go to `File` > `Settings...` (Windows/Linux), or `IntelliJ IDEA` > `Preferences...` (macOS)
. Select `Editor` > `Code Style` > `Java`
. Click on the `Imports` tab to set the order

* For `Class count to use import with '\*'` and `Names count to use static import with '*'`: Set to `999` to prevent IntelliJ from contracting the import statements
* For `Import Layout`: The order is `import static all other imports`, `import java.\*`, `import javax.*`, `import org.\*`, `import com.*`, `import all other imports`. Add a `<blank line>` between each `import`

Optionally, you can follow the <<UsingCheckstyle#, UsingCheckstyle.adoc>> document to configure Intellij to check style-compliance as you write code.

==== Updating documentation to match your fork

After forking the repo, links in the documentation will still point to the `se-edu/addressbook-level4` repo. If you plan to develop this as a separate product (i.e. instead of contributing to the `se-edu/addressbook-level4`) , you should replace the URL in the variable `repoURL` in `DeveloperGuide.adoc` and `UserGuide.adoc` with the URL of your fork.

==== Setting up CI

Set up Travis to perform Continuous Integration (CI) for your fork. See <<UsingTravis#, UsingTravis.adoc>> to learn how to set it up.

Optionally, you can set up AppVeyor as a second CI (see <<UsingAppVeyor#, UsingAppVeyor.adoc>>).

[NOTE]
Having both Travis and AppVeyor ensures your App works on both Unix-based platforms and Windows-based platforms (Travis is Unix-based and AppVeyor is Windows-based)

==== Getting started with coding

When you are ready to start coding,

1. Get some sense of the overall design by reading the link:#architecture[Architecture] section.
2. Take a look at the section link:#suggested-programming-tasks-to-get-started[Suggested Programming Tasks to Get Started].

link:#the-myths-book---developer-guide[Back To Top]

== Design

=== Architecture

image::Architecture.png[width="600"]
_Figure 2.1.1 : Architecture Diagram_

The *_Architecture Diagram_* given above explains the high-level design of the App. Given below is a quick overview of each component.

[TIP]
The `.pptx` files used to create diagrams in this document can be found in the link:{repoURL}/docs/diagrams/[diagrams] folder. To update a diagram, modify the diagram in the pptx file, select the objects of the diagram, and choose `Save as picture`.

`Main` has only one class called link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp`]. It is responsible for,

* At app launch: Initializes the components in the correct sequence, and connects them up with each other.
* At shut down: Shuts down the components and invokes cleanup method where necessary.

link:#common-classes[*`Commons`*] represents a collection of classes used by multiple other components. Two of those classes play important roles at the architecture level.

* `EventsCenter` : This class (written using https://github.com/google/guava/wiki/EventBusExplained[Google's Event Bus library]) is used by components to communicate with other components using events (i.e. a form of _Event Driven_ design)
* `LogsCenter` : Used by many classes to write log messages to the App's log file.

The rest of the App consists of four components.

* link:#ui-component[*`UI`*] : The UI of the App.
* link:#logic-component[*`Logic`*] : The command executor.
* link:#model-component[*`Model`*] : Holds the data of the App in-memory.
* link:#storage-component[*`Storage`*] : Reads data from, and writes data to, the hard disk.

Each of the four components

* Defines its _API_ in an `interface` with the same name as the Component.
* Exposes its functionality using a `{Component Name}Manager` class.

For example, the `Logic` component (see the class diagram given below) defines it's API in the `Logic.java` interface and exposes its functionality using the `LogicManager.java` class.

image::LogicClassDiagram.png[width="800"]
_Figure 2.1.2 : Class Diagram of the Logic Component_

[discrete]
==== Events-Driven nature of the design

The _Sequence Diagram_ below shows how the components interact for the scenario where the user issues the command `delete 1`.

image::SDforDeletePerson.png[width="800"]
_Figure 2.1.3a : Component interactions for `delete 1` command (part 1)_

[NOTE]
Note how the `Model` simply raises a `AddressBookChangedEvent` when the Address Book data are changed, instead of asking the `Storage` to save the updates to the hard disk.

The diagram below shows how the `EventsCenter` reacts to that event, which eventually results in the updates being saved to the hard disk and the status bar of the UI being updated to reflect the 'Last Updated' time.

image::SDforDeletePersonEventHandling.png[width="800"]
_Figure 2.1.3b : Component interactions for `delete 1` command (part 2)_

[NOTE]
Note how the event is propagated through the `EventsCenter` to the `Storage` and `UI` without `Model` having to be coupled to either of them. This is an example of how this Event Driven approach helps us reduce direct coupling between components.

The sections below give more details of each component.

=== UI component

image::UiClassDiagram.png[width="800"]
_Figure 2.2.1 : Structure of the UI Component_

*API* : link:{repoURL}/src/main/java/seedu/address/ui/Ui.java[`Ui.java`]

The UI consists of a `MainWindow` that is made up of parts e.g.`CommandBox`, `ResultDisplay`, `PersonListPanel`, `StatusBarFooter`, `BrowserPanel` etc. All these, including the `MainWindow`, inherit from the abstract `UiPart` class.

The `UI` component uses JavaFx UI framework. The layout of these UI parts are defined in matching `.fxml` files that are in the `src/main/resources/view` folder. For example, the layout of the link:{repoURL}/src/main/java/seedu/address/ui/MainWindow.java[`MainWindow`] is specified in link:{repoURL}/src/main/resources/view/MainWindow.fxml[`MainWindow.fxml`]

The `UI` component,

* Executes user commands using the `Logic` component.
* Binds itself to some data in the `Model` so that the UI can auto-update when data in the `Model` change.
* Responds to events raised from various parts of the App and updates the UI accordingly.

=== Logic component

image::LogicClassDiagram.png[width="800"]
_Figure 2.3.1 : Structure of the Logic Component_

image::LogicCommandClassDiagram.png[width="800"]
_Figure 2.3.2 : Structure of Commands in the Logic Component. This diagram shows finer details concerning `XYZCommand` and `Command` in Figure 2.3.1_

*API* :
link:{repoURL}/src/main/java/seedu/address/logic/Logic.java[`Logic.java`]

.  `Logic` uses the `AddressBookParser` class to parse the user command.
.  This results in a `Command` object which is executed by the `LogicManager`.
.  The command execution can affect the `Model` (e.g. adding a person) and/or raise events.
.  The result of the command execution is encapsulated as a `CommandResult` object which is passed back to the `Ui`.

Given below is the Sequence Diagram for interactions within the `Logic` component for the `execute("delete 1")` API call.

image::DeletePersonSdForLogic.png[width="800"]
_Figure 2.3.1 : Interactions Inside the Logic Component for the `delete 1` Command_

=== Model component

image::ModelClassDiagram.png[width="800"]
_Figure 2.4.1 : Structure of the Model Component_

*API* : link:{repoURL}/src/main/java/seedu/address/model/Model.java[`Model.java`]

The `Model`,

* stores a `UserPref` object that represents the user's preferences.
* stores the Address Book data.
* exposes an unmodifiable `ObservableList<ReadOnlyPerson>` that can be 'observed' e.g. the UI can be bound to this list so that the UI automatically updates when the data in the list change.
* does not depend on any of the other three components.

=== Storage component

image::StorageClassDiagram.png[width="800"]
_Figure 2.5.1 : Structure of the Storage Component_

*API* : link:{repoURL}/src/main/java/seedu/address/storage/Storage.java[`Storage.java`]

The `Storage` component,

* can save `UserPref` objects in json format and read it back.
* can save the Address Book data in xml format and read it back.

=== Common classes

Classes used by multiple components are in the `seedu.addressbook.commons` package.

link:#the-myths-book---developer-guide[Back To Top]

== Implementation

This section describes some noteworthy details on how certain features are implemented.

// tag::undoredo[]
=== Undo/Redo mechanism

The undo/redo mechanism is facilitated by an `UndoRedoStack`, which resides inside `LogicManager`. It supports undoing and redoing of commands that modifies the state of the address book (e.g. `add`, `edit`). Such commands will inherit from `UndoableCommand`.

`UndoRedoStack` only deals with `UndoableCommands`. Commands that cannot be undone will inherit from `Command` instead. The following diagram shows the inheritance diagram for commands:

image::LogicCommandClassDiagram.png[width="800"]

As you can see from the diagram, `UndoableCommand` adds an extra layer between the abstract `Command` class and concrete commands that can be undone, such as the `DeleteCommand`. Note that extra tasks need to be done when executing a command in an _undoable_ way, such as saving the state of the address book before execution. `UndoableCommand` contains the high-level algorithm for those extra tasks while the child classes implements the details of how to execute the specific command. Note that this technique of putting the high-level algorithm in the parent class and lower-level steps of the algorithm in child classes is also known as the https://www.tutorialspoint.com/design_pattern/template_pattern.htm[template pattern].

Commands that are not undoable are implemented this way:
[source,java]
----
public class ListCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... list logic ...
    }
}
----

With the extra layer, the commands that are undoable are implemented this way:
[source,java]
----
public abstract class UndoableCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... undo logic ...

        executeUndoableCommand();
    }
}

public class DeleteCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        // ... delete logic ...
    }
}
----

Suppose that the user has just launched the application. The `UndoRedoStack` will be empty at the beginning.

The user executes a new `UndoableCommand`, `delete 5`, to delete the 5th person in the address book. The current state of the address book is saved before the `delete 5` command executes. The `delete 5` command will then be pushed onto the `undoStack` (the current state is saved together with the command).

image::UndoRedoStartingStackDiagram.png[width="800"]

As the user continues to use the program, more commands are added into the `undoStack`. For example, the user may execute `add n/David ...` to add a new person.

image::UndoRedoNewCommand1StackDiagram.png[width="800"]

[NOTE]
If a command fails its execution, it will not be pushed to the `UndoRedoStack` at all.

The user now decides that adding the person was a mistake, and decides to undo that action using `undo`.

We will pop the most recent command out of the `undoStack` and push it back to the `redoStack`. We will restore the address book to the state before the `add` command executed.

image::UndoRedoExecuteUndoStackDiagram.png[width="800"]

[NOTE]
If the `undoStack` is empty, then there are no other commands left to be undone, and an `Exception` will be thrown when popping the `undoStack`.

The following sequence diagram shows how the undo operation works:

image::UndoRedoSequenceDiagram.png[width="800"]

The redo does the exact opposite (pops from `redoStack`, push to `undoStack`, and restores the address book to the state after the command is executed).

[NOTE]
If the `redoStack` is empty, then there are no other commands left to be redone, and an `Exception` will be thrown when popping the `redoStack`.

The user now decides to execute a new command, `clear`. As before, `clear` will be pushed into the `undoStack`. This time the `redoStack` is no longer empty. It will be purged as it no longer make sense to redo the `add n/David` command (this is the behavior that most modern desktop applications follow).

image::UndoRedoNewCommand2StackDiagram.png[width="800"]

Commands that are not undoable are not added into the `undoStack`. For example, `list`, which inherits from `Command` rather than `UndoableCommand`, will not be added after execution:

image::UndoRedoNewCommand3StackDiagram.png[width="800"]

The following activity diagram summarize what happens inside the `UndoRedoStack` when a user executes a new command:

image::UndoRedoActivityDiagram.png[width="200"]

==== Design Considerations

**Aspect:** Implementation of `UndoableCommand` +
**Alternative 1 (current choice):** Add a new abstract method `executeUndoableCommand()` +
**Pros:** We will not lose any undone/redone functionality as it is now part of the default behaviour. Classes that deal with `Command` do not have to know that `executeUndoableCommand()` exist. +
**Cons:** Hard for new developers to understand the template pattern. +
**Alternative 2:** Just override `execute()` +
**Pros:** Does not involve the template pattern, easier for new developers to understand. +
**Cons:** Classes that inherit from `UndoableCommand` must remember to call `super.execute()`, or lose the ability to undo/redo.

---

**Aspect:** How undo & redo executes +
**Alternative 1 (current choice):** Saves the entire address book. +
**Pros:** Easy to implement. +
**Cons:** May have performance issues in terms of memory usage. +
**Alternative 2:** Individual command knows how to undo/redo by itself. +
**Pros:** Will use less memory (e.g. for `delete`, just save the person being deleted). +
**Cons:** We must ensure that the implementation of each individual command are correct.

---

**Aspect:** Type of commands that can be undone/redone +
**Alternative 1 (current choice):** Only include commands that modifies the address book (`add`, `clear`, `edit`). +
**Pros:** We only revert changes that are hard to change back (the view can easily be re-modified as no data are lost). +
**Cons:** User might think that undo also applies when the list is modified (undoing filtering for example), only to realize that it does not do that, after executing `undo`. +
**Alternative 2:** Include all commands. +
**Pros:** Might be more intuitive for the user. +
**Cons:** User have no way of skipping such commands if he or she just want to reset the state of the address book and not the view. +
**Additional Info:** See our discussion  https://github.com/se-edu/addressbook-level4/issues/390#issuecomment-298936672[here].

---

**Aspect:** Data structure to support the undo/redo commands +
**Alternative 1 (current choice):** Use separate stack for undo and redo +
**Pros:** Easy to understand for new Computer Science student undergraduates to understand, who are likely to be the new incoming developers of our project. +
**Cons:** Logic is duplicated twice. For example, when a new command is executed, we must remember to update both `HistoryManager` and `UndoRedoStack`. +
**Alternative 2:** Use `HistoryManager` for undo/redo +
**Pros:** We do not need to maintain a separate stack, and just reuse what is already in the codebase. +
**Cons:** Requires dealing with commands that have already been undone: We must remember to skip these commands. Violates Single Responsibility Principle and Separation of Concerns as `HistoryManager` now needs to do two different things. +
// end::undoredo[]

// tag::addevent[]
=== Add Event mechanism

Add event mechanism adds an event which stores in the The Myth's Book. The add event mechanism is facilitated by a `EventList`, which is stored in The Myth's Book. Similar to the PersonList and TagList, the list contains the
different events with their information given by the user. This command inherits from `UndoableCommand`.

From Figure 5.2.1 below, it is visible that `AddEventCommand` inherits from `UndoableCommand` which is an extra layer between abstract `Command` class in which the SortCommand
can be undoable, where the previous state of the address book before sorting is saved.

image::AddEventDiagram.PNG[width="800"]
Figure 5.2.1 AddEventCommand Logic Class Diagram

The execution of AddEventCommand is processed in this way:

. User will execute and create a new `AddEventCommand` so as to add an event into The Myth's Book.
. When `executeUndoable()` of `AddEventCommand` is called, `model.addEvent()` in the method will be processed.
. The `internalList` of the AddressBook will store all the Events.
. After `internalList` has added the event, function `updateFilterEventList(PREDICATE_SHOW_ALL_EVENT)` is called
  to update the list being filtered and also call an event `indicatedAddressBookChanged()` to show that the addressBook has be updated
  with additional event.

The illustration of the execution is illustrated in Figure 5.2.2 below.

image::addeventmodelseqdiagram.PNG[width="800"]
Figure 5.2.2 AddEventCommand Model Sequence Diagram

Code of `AddEventCommand`:

----
    @Override
    public CommandResult executeUndoableCommand() throws CommandException {
        requireNonNull(model);
        try {
            model.addEvent(toAdd);
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (DuplicateEventException e) {
            throw new CommandException(MESSAGE_DUPLICATE_EVENT);
        }
    }
----

----
public class UniqueEventList implements Iterable<Event> {

    private final ObservableList<Event> internalList = FXCollections.observableArrayList();
    ...
    public void add(ReadOnlyEvent toAdd) throws DuplicateEventException {
        requireNonNull(toAdd);
        if (contains(toAdd)) {
            throw new DuplicateEventException();
        }
        internalList.add(new Event(toAdd));
    }
    ...
}
----

Code from `ModelManager`

----
    @Override
    public synchronized void addEvent(ReadOnlyEvent event) throws DuplicateEventException {
        addressBook.addEvent(event);
        updateFilteredEventList(PREDICATE_SHOW_ALL_EVENTS);
        indicateAddressBookChanged();
    }
----


==== Design Consideration
**Aspect:** Implementation of `AddEventCommand` +
**Alternative 1 (current choice):** Extends to UndoableCommand +
**Pros:** Developer can undo their command when they do not want to add the event. +
**Cons:** Developer has to understand the implementation of UndoableCommand +

---
**Aspect:** How does add event executes +
**Alternative 1 (current choice):** Take in Name(person) , Date(event) and Address(person) +
**Pros:** Simple to implement as add event uses the current Name for the Person as the Name of event and Address of the event due to similar CliSyntax. +
**Cons:** Developer might get confused with the different use of imports as Name and Address are from person while Date is from events. +
// end::addevent[]

// tag::switch[]
=== Switch Theme mechanism

The switch theme mechanism is facilitated by a `ThemesList`, which resides inside `AddressBook`. `ThemesList` contains a list of CSS files, in which each file are of differing colour themes for the application user interface. It sets the theme of the application to the theme specified by the index given by the user. This command will inherit from `Command`.

image::SwitchThemeCommandDiagram1.png[width="800"]

As seen in the diagram above, `SwitchThemeCommand` inherits `Command`, which means its state is not saved by the address book, and it cannot be undone after executing the command.

Suppose that the user has just launched the application. The `ThemesList` will be initialised based on the current existing colour themes.

The user executes `themeslist` to look through the existing colour themes, and pick one that he or she wants.

The user will then execute `switch 2`, with `2` being the `index` of the theme that the user prefers, provided by the executed `themeslist`.

The `ThemesList` will take the `index` provided by the user, and return a `String` of the CSS file name based on the `index`.

The execution of `switch 2` toggles an event `ChangeThemeRequestEvent`, which will then be listened and handled by `MainWindow`.

The `Stylesheets` of the `MainWindow` will then remove the current existing CSS file, which is the current theme, and add the given `String` of the CSS file into `Stylesheets`. That will set the current colour theme of `The Myth's Book` to the preferred colour theme.

Code of SwitchThemeCommand :
[source, java]
----
public class SwitchThemeCommand extends Command {
    @Override
    public CommandResult execute() {
        // ... switch theme logic ...
        EventsCenter.getInstance().post(new ChangeThemeRequestEvent(themeToChange));
    }
}
----

Listener for ChangeThemeRequestEvent in MainWindow.java :
[source,java]
----
@Subscribe
private void handleChangeThemeEvent(ChangeThemeRequestEvent event) {
    logger.info(LogsCenter.getEventHandlingLogMessage(event));
    handleChangeTheme(event.theme);
}
----

Removing and adding of CSS file into Stylesheets in MainWindow.java :
[source, java]
----
public void handleChangeTheme(String theme) {
    if (getRoot().getStylesheets().size() > 1) {
        getRoot().getStylesheets().remove(CURRENT_THEME_INDEX);
    }
    getRoot().getStylesheets().add("/view/" + theme);
}
----

The following sequence diagram shows how the switch theme operation works:

image::SwitchThemeCommandDiagram2.png[width="800"]

As seen in the diagram above, when `switch 1` is typed into the command line input, a new `SwitchThemeCommand` is created.

image::SwitchThemeCommandDiagram3.png[width="800"]

As seen in the diagram above, when `switch 1` is executed in `SwitchThemeCommand`, it will post `ChangeThemeRequestEvent` to the `EventsCenter`.

Upon detecting `ChangeThemeRequestEvent`, `Ui` will call `handleChangeTheme` to handle the event, update the `MainWindow` accordingly and update its status bar.

==== Design Considerations

**Aspect:** Implementation of `SwitchThemeCommand` +
**Alternative 1 (current choice):** Extending to `Command` class. +
**Pros:** Developers do not need to learn the implementation of `UndoableCommand` class. +
**Cons:** `SwitchThemeCommand` cannot be undone and have to repeatedly call command to switch to different themes. +
**Alternative 2:** Extending to `UndoableCommand` class. +
**Pros:** Might be more favourable to users to undo `SwitchThemeCommand` if he/she switch to an incorrect theme. +
**Cons:** Developers need to learn the implementation of `UndoableCommand`. Difficult to implement. +

---

**Aspect:** How switch theme executes +
**Alternative 1 (current choice):** Taking in index (type Integer) as the argument. +
**Pros:** Simple to implement since the index will tally with `ThemesList`. Simple to use since users don't have to remember the names and look at the index in `ThemesList`. +
**Cons:** Maybe less favourable for users when the size of `ThemesList` increase. +
**Alternative 2:** Taking in theme's name (type String) as the argument. +
**Pros:** Might be more favourable for long-time users since names may be easier to remember than numbers after using the application for a long time. +
**Cons:** Harder to implement and test. +
// end::switch[]

// tag::sort[]
=== Sort mechanism

The sort mechanism sorts the names of people inside the `addressbook` of the 'ModelManager'.
When the sort method is executed, it organizes the position of the people existing in the `addressbook`
based on their names in alphabetical order. The sort mechanism touches all components of the software application
but mainly involving the logic and model component.

In the figure [Figure 5.2.1] below, the `SortCommand` inherits from `UndoableCommand`
which is an extra layer between abstract `Command` class which belongs to the Logic Component.
This allows the SortCommand to be undoable, where the previous state of the address book before sorting is saved.

image::SortCommandLogicClassDiagram.PNG[width="800"]
Figure 5.2.1 SortCommand Logic Class Diagram

Suppose a user has an unorganized list of contacts and executes the `SortCommand` to organize his contacts.

The execution of SortCommand is processed in this way:

. User will execute and create a new `SortCommand` so as to sort the address book.
. When `executeUndoableCommand()` of `SortCommand` is called, `model.sort()` in the method will be processed.
. The `internalList` of the address book is then accessed and sorted through a `lambda` function which
  compares the name of everyone and necessarily switches the position between contacts throughout the `internalList` by comparing names between person r1 and r2 sequentially.
. After `internalList` is sorted, function `updateFilterPersonList(PREDICATE_SHOW_ALL_PERSONS)` is called
  to update the list being filtered and also call an event `indicatedAddressBookChanged()`
  to update the `PersonListPanel` of the GUI being shown.

Code of `SortCommand.java` and its method `executeUndoableCommand`:
[source,java]
----
public class SortCommand extends UndoableCommand {
    @Override
    public CommandResult executeUndoableCommand() {
        model.sort();
        return new CommandResult(MESSAGE_SUCCESS);
    }
}
----

Code of sort method inside `ModelManager.java`:
[source,java]
----
@Override
public synchronized void sort() {
    addressBook.sort();
    updateFilteredPersonList(PREDICATE_SHOW_ALL_PERSONS);
    indicateAddressBookChanged();
}
----

Code of sort method inside `UniquePersonList.java` using a lambda function to sort `internalList`:
[source,java]
----
public void sort() {
    internalList.sort((r1, r2) -> (
            r1.getName().toString().compareTo(r2.getName().toString())));
}

----
The following sequence diagram shows how the sort operation works:
As seen in the figure [Figure 5.2.2] below, when sort is typed into command line input, new `SortCommand` is created.

image::SortCommandLogicSequenceDiagram.PNG[width="800"]
Figure 5.2.2 SortCommand Logic Sequence Diagram

When `executeUndoableCommand` is called in SortCommand class, it will call the sort function in ModelManager.
It will call the sort() function of its own class until it reaches InternalList.sort() where the sorting of
contacts positions based on their names will be executed.
Ultimately, achieving the final product of having a sorted addressbook being shown in the `PersonListPanel`

image::SortCommandModelSequenceDiagram.PNG[width="800"]
Figure 5.2.3 SortCommand Model Sequence Diagram

==== Design Considerations
**Aspect:** Implementation of `SortCommand` +
**Alternative 1 (current choice):** extending to `UndoableCommand` class +
**Pros:** Sort method call is able to be undone if needed as it now inherits from the Super Class. +
**Cons:** Developers might need to understand how `UndoableCommand` works before implementation. +
**Alternative 2:** Just extend to `Command` class +
**Pros:** Does not need understanding of `UndoableCommand` class. +
**Cons:** Unable to undo sort method and work from previous state of address book if user has called `SortCommand` to sort address book.

---
**Aspect:** Implementation of how sort executes +
**Alternative 1 (current choice):** Compare and sort the names of every individual alphabetically. +
**Pros:** Easy to implement and uses less complexity. +
**Cons:** Unable to sort based on user preferences like email, phone number. +
**Alternative 2:** Include all types of sorting like sorting phone numbers and emails. +
**Pros:** Might be more favourable for user who have specific needs to collate certain information such as
 email or phone number about his contacts in an alphanumeric order. +
**Cons:** Difficult to implement and wastes memory space as sorting might be unnecessary and complex for general users
          since main goal is to keep address book organized. +

---
//end::sort[]

// tag::access[]
=== Access Website mechanism

The access website mechanism has an `AccessCommand` that allows user to access the website by stating the
index of the desired contact in the contact list viewed.
The implementation of the access website mechanism is mostly done in the `UI`, `Model`, and `Logic` component.
The `AccessCommand` class inherits from the `Command` class.

Suppose a user would like to access one of his contacts website that is listed in the `PersonListPanel` of the address book
and executes the `AccessCommand` to access the website.

The execution of AccessCommand is processed in this way:

. User will input `access index` where `index` refers to the index of the person listed in the `PersonListPanel` in GUI.
. Input of user will be parse as an argument through the AddressBookParser and AccessCommandParser to extract the index.
. A new `AccessCommand` with the index inputted will be created.
. The method `execute()` of the `AccessCommand` will then be processed,
 where the person of the website that the user wants to access will be obtained through the
 index of the `lastShownList` and stored into `person` variable which is of `ReadOnlyPerson` data-type.
. The `EventsCenter` will then post a new `AccessWebsiteRequestEvent` with parameter input of the `website` of the `person` variable.
. The `AccessWebsiteRequestEvent` event would then be handled by an event handler `handleAccessWebsiteEvent` in `BrowserPanel`.
. The event handler will help to load the website of the person through the browser panel based on the website inputted.

Code of `AccessCommand` and its method `execute()`:
[source,java]
----
public class AccessCommand extends Command {
    private final Index targetIndex;

    // ... access logic ...
    public AccessCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
        }

        ReadOnlyPerson person = lastShownList.get(targetIndex.getZeroBased());
        String name = person.getName().toString();
        String website = person.getWebsite().toString();

        if (website.equals("NIL")) {
            throw new CommandException(Messages.MESSAGE_INVALID_WEBSITE);
        }

        EventsCenter.getInstance().post(new AccessWebsiteRequestEvent(website));
        return new CommandResult(String.format(MESSAGE_ACCESS_PERSON_SUCCESS, targetIndex.getOneBased(), name));
    }
}
----

Code of how accessing website event is handled in `BrowserPanel`:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {
    public void handleWebsiteAccess(String website) {
        browserPanel.loadPage(website);
    }

    public void loadPage(String url) {
        Platform.runLater(() -> browser.getEngine().load(url));
    }

    @Subscribe
    private void handleAccessWebsiteEvent(AccessWebsiteRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        handleWebsiteAccess(event.website);
    }
}
----

Through the sequence diagram, you can see how the code executes when a user
inputs `access 1` into the command line.

Sequence diagram for `Logic` Component for `AccessCommand` and how it is executed:

image::AccessCommandLogicSequenceDiagram.PNG[width="800"]
Figure 5.6.1 Access Command Logic Sequence Diagram

After creating a new `AccessCommand`, `LogicManager` will call execute on `AccessCommand`
and this will result in the website of the person at the index inputted to be called through an event request and event handler.
The website will then be loaded onto the browser of the `BrowserPanel` of the `MainWindow`.

Sequence diagram for `execute()` method of `AccessCommand` and its event handling:

image::AccessCommandEventsSequenceDiagram.PNG[width="800"]
Figure 5.6.2 Access Command Model/EventsCenter/UI Sequence Diagram

==== Design Considerations
**Aspect:** How accessing a website of a person executes +
**Alternative 1 (current choice):** Create a new event request and event handler for AccessCommand. +
**Pros:** Able to have more features like AccessWebsite and Select feature that is able to exist concurrently in the application. +
**Cons:** Having the current select feature which is to search for names of contact of Google is quite unnecessary. +
**Alternative 2:** Change the code of event request and event handler related to SelectCommand to allow users to access website of their contacts instead
of creating a search on contacts name through the browser panel. +
**Pros:** Select feature which seems unnecessary is replaced with a more useful feature of AccessWebsite. +
**Cons:** Will not be able to replace the select feature anymore which might be important for other aspects such as creating a Person Card Viewer
which is important for GUI enhancement. +

//end::access[]

// tag::locate[]
=== Location mechanism
The location mechanism has an `LocationCommand` that allows user to access the address through Google Maps Search
by stating the index of the desired contact in the contact list viewed.
The implementation of the location mechanism is mostly done in the `UI`, `Model`, and `Logic` component
and is very similar to the access website mechanism in terms of implementation and sequential process.
The `LocationCommand` class inherits from the `Command` class.

Suppose a user would like to access one of his contacts address that is listed in the `PersonListPanel` of the address book
and executes the `LocationCommand` to access the location using the address attained.

The execution of LocationCommand is processed in this way:

. User will input `locate index` where `index` refers to the index of the person listed in the `PersonListPanel` in GUI.
. Input of user will be parse as an argument through the AddressBookParser and LocationCommandParser to extract the index.
. A new `LocationCommand` with the index inputted will be created.
. The method `execute()` of the `LocationCommand` will then be processed,
 where the person of the address that the user wants to find on Google Maps Search will be obtained through the
 index of the `lastShownList` and stored into `person` variable which is of `ReadOnlyPerson` data-type.
. The `EventsCenter` will then post a new `AccessLocationRequestEvent` with parameter input of the `address` of the `person` variable.
. The `AccessLocationRequestEvent` event would then be handled by an event handler `handleAccessLocationEvent` in `BrowserPanel`.
. The event handler will help to load the address of the person through Google Maps Search in the browser panel.

Code of `LocationCommand` and its method `execute()`:
[source,java]
----
public class LocationCommand extends Command {
    private final Index targetIndex;

    public LocationCommand(Index targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() throws CommandException {
        List<ReadOnlyPerson> lastShownList = model.getFilteredPersonList();

        if (targetIndex.getZeroBased() >= lastShownList.size()) {
            throw new CommandException(Messages.MESSAGE_INVALID_DISPLAYED_INDEX);
        }

        ReadOnlyPerson person = lastShownList.get(targetIndex.getZeroBased());
        String name = person.getName().toString();
        String location = person.getAddress().toString();
        if (location.equals("NIL")) {
            throw new CommandException(Messages.MESSAGE_INVALID_LOCATION);
        }

        EventsCenter.getInstance().post(new AccessLocationRequestEvent(location));
        return new CommandResult(String.format(MESSAGE_LOCATE_PERSON_SUCCESS, targetIndex.getOneBased(), name));
    }
}
----

Code of how accessing location event is handled in `BrowserPanel`:
[source,java]
----
public class BrowserPanel extends UiPart<Region> {
    public static final String GOOGLE_SEARCH_URL_PREFIX = "https://www.google.com.sg/maps?safe=off&q=";
    public static final String GOOGLE_SEARCH_URL_SUFFIX = "&cad=h";

    private void loadPersonLocation(String location) {
        loadPage(GOOGLE_SEARCH_URL_PREFIX + location.replaceAll(" ", "+")
                + GOOGLE_SEARCH_URL_SUFFIX);
    }

    public void loadPage(String url) {
        Platform.runLater(() -> browser.getEngine().load(url));
    }

    @Subscribe
    private void handleAccessLocationEvent(AccessLocationRequestEvent event) {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        loadPersonLocation(event.location);
    }
}
----

Through the sequence diagram, you can see how the code executes when a user
inputs `locate 1` into the command line.

Sequence diagram for `Logic` Component for `LocationCommand` and how it is executed:

image::LocationCommandLogicSequenceDiagram.png[width="800"]
Figure 5.7.1 Location Command Logic Sequence Diagram

After creating a new `LocationCommand`, `LogicManager` will call execute on `LocationCommand`
and this will result in the address of the person at the index inputted to be called through an event request and event handler.
The address will then be loaded onto Google Maps Search of the browser of the `MainWindow`.

Sequence diagram for `execute()` method of `LocationCommand` and its event handling:

image::LocationCommandEventsSequenceDiagram.png[width="800"]
Figure 5.7.2 Access Command Model/EventsCenter/UI Sequence Diagram

==== Design Considerations
**Aspect:** How accessing a location of a person executes +
**Alternative 1 (current choice):** Create a new event request and event handler for LocationCommand. +
**Pros:** Able to have more features like Location, AccessWebsite and Select feature that is able to exist concurrently in the application. +
**Cons:** Having the current select feature which is to search for names of contact of Google is quite unnecessary. +
**Alternative 2:** Change the code of event request and event handler related to SelectCommand to allow users to access the address through Google Maps Search instead
of processing a search on contact's name through the google search using browser. +
**Pros:** Select feature which seems unnecessary is replaced with a more useful feature of AccessWebsite. +
**Cons:** Will not be able to replace the select feature anymore which might be important for other aspects such as creating a PersonCard Viewer
which is important for GUI enhancement. +

//end::locate[]

// tag::find[]
=== Find mechanism
The find mechanism is facilitated by the `NameContainsKeyWordsPredicate` class which resides in the person class. It supports finding any person in the address book using their full name or a part of the name.

However, if a user is searching by part of a name, the substring must be in the beginning of the first name or last name and it has to be at least two characters long.

The `find` command is not an undoable command and therefore it inherits from `Command` rather than `UndoableCommand`.

The `NameContainsKeyWordsPredicate` class has a test function that uses stream, a new feature of Java 8 to process data more efficiently than using loops. The `test()` returns true if either the full name(first name + last name) ignoring case or it contains a substring of the name ignoring case.

The main logic in the `NameContainsKeyWordsPredicate` class comes from the `StringUtil` class that acts as a helper function for handling any operations related to strings.

How the `containsPartofWord()` function works:
[source,java]
----
public static boolean containsPartOfWord(String sentence, String word) {
    requireNonNull(sentence);
    requireNonNull(word);
    ...
}
----

The function takes in two string arguments, one being the name of the person and the other being the substring. The function first checks to see if either of these arguments are null using java.util.Objects.requireNonNull. If any of the arguments are null, it throws a NullPointerException.
[source,java]
----
public static boolean containsPartOfWord(String sentence, String word) {
    ....
    checkArgument(preppedWord.split("\\s+").length == 1, "Word parameter should be a single word");
    String preppedSentence = sentence;
    String[] wordsInPreppedSentence = preppedSentence.split("\\s+");
    ...
}
----

If both strings are valid, it then checks that the substring is only one word. The function then splits up the person’s name into first name and last name.
[source,java]
----
public static boolean containsPartOfWord(String sentence, String word) {
    ....
    if (preppedWord.length() >= 2) {
        for (String wordInSentence : wordsInPreppedSentence) {
            if ((wordInSentence.toLowerCase().contains(preppedWord.toLowerCase()))
                && (wordInSentence.toLowerCase().startsWith(preppedWord.toLowerCase()))) {
            return true;
            }
        }
    ....
----
The function first checks if the length of the substring is greater than, equal to 2. Using an enhanced for loop, the function iterates through the words in a person’s name and checks to see if any of them start with the substring ignoring cases.

If yes, then the function returns true else it returns false.

==== Design Considerations
**Aspect:** Implementation of `containsPartOfWord` +
**Alternative 1 (current choice):** length>=2 +
**Pros:** Making sure that not every person's name comes up in find. For e.g: 'find a' +
**Cons:** There might exist people whose first or last name is stored as a single character +
**Alternative 2:** Allow any length of substrings +
**Pros:** No exception cases +
**Cons:** No purpose of using find as if you search for one character, all contacts might get filtered +
// end::find[]

//tag::birthday[]
=== Birthdays mechanism
The Birthdays mechanism is facilitated by the `CheckIfBirthday` class which resides in the person class. It lists out all contacts that have their birthdays today.

The `Birthdays` command is not an undoable command and thus inherits from `Command` rather than `UndoableCommand`.

The `CheckIfBirthday` class checks if the birth month and day of a contact matches today. As the birthday field is a birthday object, it is converted to a string using the `toString()` method in the `Birthday` class and then parsed into a date object using `simpleDateFormat()`.
[source,java]
----
 Date date = new SimpleDateFormat("dd/MM/yyyy").parse(birthday);
----

The date is then converted into a `Calendar` object for easier comparison. Then the Day and Month of today is compared with the day and month of a person's birthday in the following way.
[source,java]
----
return (((cal.get(Calendar.MONTH)) == Calendar.getInstance().get(Calendar.MONTH))
                && ((cal.get(Calendar.DAY_OF_MONTH) == Calendar.getInstance().get(Calendar.DAY_OF_MONTH))));
    }
----

An overall view of birthdays command logic is shown in Figure 5.8.1

image::BirthdaysMechanism.png[width="800"]
Figure 5.8.1 Birthdays Command Logic Sequence Diagram

What the user finally sees is a list of people with their birthday today as shown in figure 5.8.2. This is because the `executeUndoableCommand()` which is overriden in the BirthdaysCommand class updates the `filteredPersonList`.
[source,java]
----
 @Override
    public CommandResult executeUndoableCommand() {
        model.updateFilteredPersonList(check);
        return new CommandResult(getBirthdayMessageSummary(model.getFilteredPersonList().size()));
    }
----

image::BirthdaysMechanism2.png[width="200"]
Figure 5.8.2 What the user sees

==== Design Considerations
**Aspect:** UI of `BirthdaysCommand` +
**Alternative 1 (current choice):** Showing the persons as a list +
**Pros:** g: Voluntary action. users can check birthday if they want to and won't get confused even if there are multiple contacts with the same name as to whose birthday it is +
**Cons:** Some users might want the birthdays to appear as a pop up +
**Alternative 2:** Use a pop up which is triggered when the app is opened +
**Pros:** Involuntary and less effort from the users' part +
**Cons:** If pop up only shows a list of names, users might get confused as to who the person is if there are multiple persons with the same name. +
//end::birthday[]

//tag::calendar[]
=== Calendar mechanism

The Calendar is created with GridPanes and VBox. The following code snippets describes how the `AnchorPaneNode` object fills up the
GridPane of the calendar. At the end of the method, the VBox gathers all the required parameters to get the view of the calendar.

----
    public Calendar(YearMonth yearMonth, ObservableList<ReadOnlyEvent> eventList) {
        currentYearMonth = yearMonth;
        // Create the calendar grid pane
        GridPane calendar = new GridPane();
        calendar.setPrefSize(600, 400);
        // Create rows and columns with anchor panes for the calendar
        for (int i = 0; i < 5; i++) {
            for (int j = 0; j < 7; j++) {
                AnchorPaneNode ap = new AnchorPaneNode();
                ap.setPrefSize(200, 200);
                calendar.add(ap, j, i);
                allCalendarDays.add(ap);
                ap.getStyleClass().add("calendar-color");
            }
        }

        // Days of the week labels
        Text[] dayNames = new Text[]{new Text("Sunday"), new Text("Monday"),
                          new Text("Tuesday"), new Text("Wednesday"), new Text("Thursday"),
                          new Text("Friday"), new Text("Saturday")};

        GridPane dayLabels = new GridPane();
        dayLabels.setPrefWidth(600);
        Integer col = 0;
        for (Text txt : dayNames) {
            txt.getStyleClass().add("calendar-color");
            AnchorPane ap = new AnchorPane();
            ap.setPrefSize(200, 10);
            ap.setBottomAnchor(txt, 5.0);
            ap.getChildren().add(txt);
            dayLabels.add(ap, col++, 0);
        }

        // Create calendarTitle and buttons to change current month
        calendarTitle = new Text();
        calendarTitle.getStyleClass().add("calendar-color");
        Button previousMonth = new Button("<");
        previousMonth.setOnAction(e -> previousMonth());
        Button nextMonth = new Button(">");
        nextMonth.setOnAction(e -> nextMonth());
        HBox titleBar = new HBox(previousMonth, calendarTitle, nextMonth);
        titleBar.setSpacing(5);
        titleBar.setAlignment(Pos.BASELINE_CENTER);
        // Populate calendar with the appropriate day numbers
        populateCalendar(yearMonth, eventList);
        // Create the calendar view
        view = new VBox(titleBar, dayLabels, calendar);
    }
----

Now, you have the Calendar outline, the populateCalendar method calendar called will then populate the Calendar with the individual dates of the months.
During the process, we would check if is there any events that are on the date corresponding to the AnchorPaneNode. If it tallies, the AnchorPaneNode will
be populated with a change in background color.

----
    public void populateCalendar(YearMonth yearMonth, ObservableList<ReadOnlyEvent> events) {
        // Get the date we want to start with on the calendar
        LocalDate calendarDate = LocalDate.of(yearMonth.getYear(), yearMonth.getMonthValue(), 1);
        // Dial back the day until it is SUNDAY (unless the month starts on a sunday)
        while (!calendarDate.getDayOfWeek().toString().equals("SUNDAY")) {
            calendarDate = calendarDate.minusDays(1);
        }
        // Populate the calendar with day numbers
        for (AnchorPaneNode ap : allCalendarDays) {
            if (ap.getChildren().size() != 0) {
                ap.getChildren().remove(0);
            }
            Text txt = new Text(String.valueOf(calendarDate.getDayOfMonth()));
            txt.getStyleClass().add("calendar-color");
            ap.setDate(calendarDate);
            ap.setTopAnchor(txt, 5.0);
            ap.setLeftAnchor(txt, 5.0);
            ap.setStyle("calendar-color");
            ap.getChildren().add(txt);
            calendarDate = calendarDate.plusDays(1);
        }

        for (AnchorPaneNode ap : allCalendarDays) {
            DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d/MM/yyyy");
            String newDate = formatter.format(ap.getDate());
            for (ReadOnlyEvent event : events) {
                String date = event.getDate().toString();
                if (newDate.equals(date)) {
                    ap.getChildren();
                    ap.setStyle("-fx-background-color: #ffebcd;");
                }
            }
        }
        // Change the title of the calendar
        calendarTitle.setText(yearMonth.getMonth().toString() + " " + String.valueOf(yearMonth.getYear()));
    }
----

The updating of different months and population of event nodes are done by the two separate methods that will post events to
`EventsCenter` to update the calendar based on the `UniqueEventList`.

----
    public void previousMonth() {
        currentYearMonth = currentYearMonth.minusMonths(1);
        EventsCenter.getInstance().post(new PopulateMonthEvent(currentYearMonth));
    }
    public void nextMonth() {
        currentYearMonth = currentYearMonth.plusMonths(1);
        EventsCenter.getInstance().post(new PopulateMonthEvent(currentYearMonth));
    }
----

The mechanism behind the process of adding an event from the dialog box is shown in Figure 5.9.1 below.

image::dialogaddeventsequencediagram.PNG[width="800"]
Figure 5.9.1 Dialog Add Event Sequence Diagram

From the startDialog method in `AnchorPaneNode` class, after receiving a valid Event, an `AddEventRequestEvent` object will be posted to `EventsCenter`.
Then with the `@Subscribe` function, a handleAddEvent() method in `ModelManager` will be called to addEvent of the `AddressBook` object. The following code snippets
shows the key implementation of how an Event object is added to the addressbook.

----
   dialog.setResultConverter(dialogButton -> {
        if (dialogButton == button) {
                return new BuildEvent().withName(text1.getText()).withDate(date).withAddress(text2.getText()).build();
            }
            return null;
        });

        Optional<Event> result = dialog.showAndWait();
        result.ifPresent(event -> {
            EventsCenter.getInstance().post(new AddEventRequestEvent(event));
   });
----

----
    @Subscribe
    private void handleAddEvent(AddEventRequestEvent event) throws DuplicateEventException {
        logger.info(LogsCenter.getEventHandlingLogMessage(event));
        addressBook.addEvent(event.event);
        updateFilteredEventList(PREDICATE_SHOW_ALL_EVENTS);
        indicateAddressBookChanged();
    }
----

Population of the calendar after Adding or Delete of Events will be completed by this method in the `Calendar.java` class.
It reverts every node to be of the same color, then runs through the events list to update the individual event node.

----
    public void populateUpdatedCalendar(UniqueEventList eventList) {
        for (AnchorPaneNode ap : allCalendarDays) {
            ap.setStyle("calendar-color");
            for (Event event1 : eventList) {
                DateTimeFormatter formatter = DateTimeFormatter.ofPattern("d/MM/yyyy");
                String newDate = formatter.format(ap.getDate());
                if (newDate.equals(event1.getDate().toString())) {
                    ap.getChildren();
                    ap.setStyle("-fx-background-color: #ffebcd;");
                }
            }
        }
    }
----

==== Design Considerations

**Aspect:** UI of `Calendar` +
**Alternative 1 (current choice):** Showing the calendar on a GridPane +
**Pros:** A customizable calendar for the user and easy access to add an event on the calendar  +
**Cons:** Some users might want to have better user interface experience +
**Alternative 2:** Google calendar implementation +
**Pros:** Ready made calendar for developers to implement +
**Cons:** Difficult to apply changes and suit the calendar to be as what user wants. +

//end::calendar[]

=== Logging

We are using `java.util.logging` package for logging. The `LogsCenter` class is used to manage the logging levels and logging destinations.

* The logging level can be controlled using the `logLevel` setting in the configuration file (See link:#configuration[Configuration])
* The `Logger` for a class can be obtained using `LogsCenter.getLogger(Class)` which will log messages according to the specified logging level
* Currently log messages are output through: `Console` and to a `.log` file.

*Logging Levels*

* `SEVERE` : Critical problem detected which may possibly cause the termination of the application
* `WARNING` : Can continue, but with caution
* `INFO` : Information showing the noteworthy actions by the App
* `FINE` : Details that is not usually noteworthy but may be useful in debugging e.g. print the actual list instead of just its size


=== Configuration

Certain properties of the application can be controlled (e.g App name, logging level) through the configuration file (default: `config.json`).

link:#the-myths-book---developer-guide[Back To Top]

== Documentation

We use asciidoc for writing documentation.

[NOTE]
We chose asciidoc over Markdown because asciidoc, although a bit more complex than Markdown, provides more flexibility in formatting.

=== Editing Documentation

See <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to learn how to render `.adoc` files locally to preview the end result of your edits.
Alternatively, you can download the AsciiDoc plugin for IntelliJ, which allows you to preview the changes you have made to your `.adoc` files in real-time.

=== Publishing Documentation

See <<UsingTravis#deploying-github-pages, UsingTravis.adoc>> to learn how to deploy GitHub Pages using Travis.

=== Converting Documentation to PDF format

We use https://www.google.com/chrome/browser/desktop/[Google Chrome] for converting documentation to PDF format, as Chrome's PDF engine preserves hyperlinks used in webpages.

Here are the steps to convert the project documentation files to PDF format.

.  Follow the instructions in <<UsingGradle#rendering-asciidoc-files, UsingGradle.adoc>> to convert the AsciiDoc files in the `docs/` directory to HTML format.
.  Go to your generated HTML files in the `build/docs` folder, right click on them and select `Open with` -> `Google Chrome`.
.  Within Chrome, click on the `Print` option in Chrome's menu.
.  Set the destination to `Save as PDF`, then click `Save` to save a copy of the file in PDF format. For best results, use the settings indicated in the screenshot below.

image::chrome_save_as_pdf.png[width="300"]
_Figure 5.6.1 : Saving documentation as PDF files in Chrome_

link:#the-myths-book---developer-guide[Back To Top]

== Testing

=== Running Tests

There are three ways to run tests.

[TIP]
The most reliable way to run tests is the 3rd one. The first two methods might fail some GUI tests due to platform/resolution-specific idiosyncrasies.

*Method 1: Using IntelliJ JUnit test runner*

* To run all tests, right-click on the `src/test/java` folder and choose `Run 'All Tests'`
* To run a subset of tests, you can right-click on a test package, test class, or a test and choose `Run 'ABC'`

*Method 2: Using Gradle*

* Open a console and run the command `gradlew clean allTests` (Mac/Linux: `./gradlew clean allTests`)

[NOTE]
See <<UsingGradle#, UsingGradle.adoc>> for more info on how to run tests using Gradle.

*Method 3: Using Gradle (headless)*

Thanks to the https://github.com/TestFX/TestFX[TestFX] library we use, our GUI tests can be run in the _headless_ mode. In the headless mode, GUI tests do not show up on the screen. That means the developer can do other things on the Computer while the tests are running.

To run tests in headless mode, open a console and run the command `gradlew clean headless allTests` (Mac/Linux: `./gradlew clean headless allTests`)

=== Types of tests

We have two types of tests:

.  *GUI Tests* - These are tests involving the GUI. They include,
.. _System Tests_ that test the entire App by simulating user actions on the GUI. These are in the `systemtests` package.
.. _Unit tests_ that test the individual components. These are in `seedu.address.ui` package.
.  *Non-GUI Tests* - These are tests not involving the GUI. They include,
..  _Unit tests_ targeting the lowest level methods/classes. +
e.g. `seedu.address.commons.StringUtilTest`
..  _Integration tests_ that are checking the integration of multiple code units (those code units are assumed to be working). +
e.g. `seedu.address.storage.StorageManagerTest`
..  Hybrids of unit and integration tests. These test are checking multiple code units as well as how the are connected together. +
e.g. `seedu.address.logic.LogicManagerTest`


=== Troubleshooting Testing
**Problem: `HelpWindowTest` fails with a `NullPointerException`.**

* Reason: One of its dependencies, `UserGuide.html` in `src/main/resources/docs` is missing.
* Solution: Execute Gradle task `processResources`.

link:#the-myths-book---developer-guide[Back To Top]

== Dev Ops

=== Build Automation

See <<UsingGradle#, UsingGradle.adoc>> to learn how to use Gradle for build automation.

=== Continuous Integration

We use https://travis-ci.org/[Travis CI] and https://www.appveyor.com/[AppVeyor] to perform _Continuous Integration_ on our projects. See <<UsingTravis#, UsingTravis.adoc>> and <<UsingAppVeyor#, UsingAppVeyor.adoc>> for more details.

=== Making a Release

Here are the steps to create a new release.

.  Update the version number in link:{repoURL}/src/main/java/seedu/address/MainApp.java[`MainApp.java`].
.  Generate a JAR file <<UsingGradle#creating-the-jar-file, using Gradle>>.
.  Tag the repo with the version number. e.g. `v0.1`
.  https://help.github.com/articles/creating-releases/[Create a new release using GitHub] and upload the JAR file you created.

=== Managing Dependencies

A project often depends on third-party libraries. For example, Address Book depends on the http://wiki.fasterxml.com/JacksonHome[Jackson library] for XML parsing. Managing these _dependencies_ can be automated using Gradle. For example, Gradle can download the dependencies automatically, which is better than these alternatives. +
a. Include those libraries in the repo (this bloats the repo size) +
b. Require developers to download those libraries manually (this creates extra work for developers)

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== User Stories

Priorities: High (must have) - `* * \*`, Medium (nice to have) - `* \*`, Low (unlikely to have) - `*`

[width="59%",cols="22%,<23%,<25%,<30%",options="header",]
|=======================================================================
|Priority |As a ... |I want to ... |So that I can...
|`* * *` |user |add a new person |store more information about people around me

|`* * *` |user |delete a person |remove entries that I no longer need

|`* * *` |user |request for a help guide |know more about the address book and use it with less difficulty

|`* * *` |user |list and view all my contacts |browse through my stored contacts and in the event of not being able to search for them

|`* * *` |user |edit a person's information |constantly update or correct a contact's information

|`* * *` |user |select a person by index |use the information provided to search on Google

|`* * *` |user |view the history of the commands inputted |know which steps have been made to the addressbook

|`* * *` |user |undo the commands that were inputted |revert unnecessary or unwanted changes

|`* * *` |user |redo the commands that is undone |revert changes that were undone

|`* * *` |user |clear entries in my addressbook |remove unnecessary information of my contacts or remake a new contact list

|`* * *` |user |exit the program |

|`* * *` |user |find a person by name |locate details of persons without having to go through the entire list

|`* * *` |new user |see usage instructions |refer to instructions when I forget how to use the App

|`* * *` |user |have a CLI prompt that can exhibit the required information to add an individual  |avoid inputting the wrong information

|`* * *` |user |store multiple phone numbers and email addresses for any contact |store extra communication information of my contact

|`* * *` |social user |access Facebook, LinkedIn and Google |search and add my contacts on respective websites

|`* * *` |user |have a confirmation request of the details inputted before adding an individual|make changes to any errors inputted

|`* * *` |responsible user |have a confirmation request & warning message upon using the clear command |avoid accidentally clearing my address book

|`* * *` |user |find contacts based on part of their names |ease the search for the necessary contacts without being too specific in spelling names

|`* * *` |user |find users based on any of their details (i.e. phone or tag) |find the person more easily

|`* * *` |user |have a filter system to find contacts first by name, and then any additional relevant information(tags or email addresses) |search for a person more accurately in the case of multiple people with similar names.

|`* * *` |organized user |sort my contacts in an alphabetical order |view my overall contact list in an alphabetically organized manner

|`* *` |user |hide link:#private-contact-detail[private contact details] by default |minimize chance of someone else seeing them by accident

|`* *` |user |have directions to the contact's address with Google Maps from current location |have direct and easier access in being referred to the location in Google Maps application

|`* *` |user |choose various colour themes for the address book |view the address book in my favourite visuals

|`* *` |social user |add some important people to a favourites list |access my favourite contacts easily

|`* *` |task-oriented user |see my most viewed contacts on a "speed check" tab |search quickly for contacts that i often search for based on the number of times i searched for them

|`* *` |task-oriented user |sort the list of contacts based on their details |view contacts based on my preferable detail i am wishing to search for

|`* *` |responsible user |save my contacts list in a portable format |keep a soft copy of it and be able to retrieve if i lost my original contact list or want to access it in another computer

|`* *` |social user |add organisations/groups |search for individuals based on their organization groups

|`* *` |social user |store internet links to their organization website, github, linkedIn or facebook |more information on my contacts

|`* *` |social user |have the option to add a picture of an individual |recognize contacts by their facial features.

|`* *` |task-oriented user |get reminders |know if i am attending an event with another contact, or if it is the contact's birthday

|`* *` |task-oriented user |be able to create appointments with my contacts |be notified of my upcoming meetings

|`* *` |social user |add birthday information to my contact in the address book |have easier access to the upcoming birthday dates of the people around me

|=======================================================================

Social user - a user who likes to know more information about the people around them so as to understand them better +
Task-oriented user - a user who prefers to have purposeful functions which would help facilitate easier access towards executing his work +
{More to be added}

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Use Cases

(For all use cases below, the *System* is the `AddressBook` and the *Actor* is the `user`, unless specified otherwise)

=== Use case: Delete person

*MSS*

1.  User requests to list persons
2.  AddressBook shows a list of persons
3.  User requests to delete a specific person in the list
4.  AddressBook deletes the person
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

* 3a. The given index is invalid.
+
[none]
** 3a1. AddressBook shows an error message.
+
Use case resumes at step 2.

=== Use case: Sort list

*MSS*

1.  User requests to list persons
2.  AddressBook shows a list of persons
3.  User requests to sort list
4.  AddressBook sorts the list of persons
5.  AddressBook shows sorted list of persons
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

[none]
* 5a. The list is empty.
+
Use case ends.

=== Use case: Find person

*MSS*

1.  User requests to find person with keyword (name or first few characters of name)
2.  AddressBook shows a list of persons with keyword
+
Use case ends.

*Extensions*

* 1a. Person name is invalid
[none]
** 1a1. AddressBook shows an error message.
+
Use case ends.

=== Use case: Add person

*MSS*

1.  User requests to add person
2.  User types in details of person to add
3.  AddressBook shows details of person to add
4.  AddressBook requests confirmation to add person
5.  User confirms adding of person
6.  AddressBook adds person to list of persons
7.  AddressBook shows updated list of persons with added person
+
Use case ends.

*Extensions*

* 2a. Details are invalid.
+
[none]
** 2a1. AddressBook shows an error message.
+
Use case resumes at step 1.

* 5a. User denies adding of person.
+
[none]
** 5a1. AddressBook requests details to edit
** 5a2. User types in new, edited details
+
Use case resumes at step 3.

=== Use case: Undo command

*MSS*

1.  User uses add, delete, edit or clear command
2.  User requests undo of command
3.  AddressBook returns to the state before the command
4.  AddressBook shows updated state
+
Use case ends.

*Extensions*

* 2a. No more commands to undo.

+
[none]
** 2a1. AddressBook shows an error message.
+
Use case ends.

=== Use case: List persons

*MSS*

1.  User requests to list persons
2.  AddressBook shows a list of persons
+
Use case ends.

*Extensions*

[none]
* 2a. The list is empty.
+
Use case ends.

=== Use case: List Birthdays

*MSS*

1.  User wants to know if any person has a birthday today.
2.  User requests birthdays command.
3.  AddressBook lists all persons with birthday today.
+
Use case ends.

*Extensions*

[none]
* 2a. No birthdays today.
+
Use case ends.

=== Use case: Add event

*MSS*

1. User requests to add event
2. User types in details of event to add
3. AddressBook shows details of event to add
4. AddressBook request confirmation to add event
5. User confirms adding of event
6. AddressBok adds event to list of events

Use case ends

=== Use case: Access website

*MSS*

1. User chooses to access a contact's website.
2. AddressBook requests for details of the access.
3. User enters the requested details which includes the index of the desired contact.
4. AddressBook shows the website of the desired contact for user to use.

Use case ends.

*Extensions*

* 3a. AddressBook detects an error in the entered data.
+
[none]
** 3a1. AddressBook shows an error message and requests for correct data.
** 3a2. User enters new data.
+
Steps 3a1-3a2 are repeated until the data entered are correct.
+
Use case resumes at step 4.

=== Use case: Access Location

*MSS*

1. User chooses to access a contact's location.
2. AddressBook requests for details of the access.
3. User enters the requested details which includes the index of the desired contact.
4. AddressBook shows the location of the desired contact for user to view.

Use case ends.

*Extensions*

* 3a. AddressBook detects an error in the entered data.
+
[none]
** 3a1. AddressBook shows an error message and requests for correct data.
** 3a2. User enters new data.
+
Steps 3a1-3a2 are repeated until the data entered are correct.
+
Use case resumes at step 4.


{More to be added}

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Non Functional Requirements

.  Should work on any link:#mainstream-os[mainstream OS] as long as it has Java `1.8.0_60` or higher installed.
.  Should be able to hold up to 1000 persons without a noticeable sluggishness in performance for typical usage.
.  A user with above average typing speed for regular English text (i.e. not code, not system admin commands) should be able to accomplish most of the tasks faster using commands than using the mouse.
.  Should be able to work for 32-bit and 64-bit systems.
.  Should be able to respond within a second.
.  Should be able to be used by any individual who has not used an address book before.
.  The source code should be open source.
.  Should maintain application every month.
.  Should be able to retrieve, save and use on another computer.
.  A user should be able to back up and restore all contacts if application breakdown.

{More to be added}

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Glossary

[[mainstream-os]]
Mainstream OS

....
Windows, Linux, Unix, OS-X
....

[[abstract]]
Abstract

....
An abstract class is a class that is declared abstract—it may or may not include abstract methods. Abstract classes cannot be instantiated, but they can be subclassed.
An abstract method is a method that is declared without an implementation
....

[[API]]
API

....
Application Programming Interface (API)is a collection of pre-written packages,
classes, and interfaces with their respective methods, fields and constructors.
....

[[javaFX]]
JavaFX

....
JavaFX is a software platform for creating and delivering desktop applications,
as well as rich internet applications (RIAs) that can run across a wide variety of devices.
....

[[gradle]]
Gradle

....
Gradle is an open source build automation system that builds upon the concepts of Apache Ant and Apache Maven.
....

link:#the-myths-book---developer-guide[Back To Top]

[appendix]
== Product Survey

*Product Name*

Author: ...

Pros:

* ...
* ...

Cons:

* ...
* ...

link:#the-myths-book---developer-guide[Back To Top]
